Tool: ChatGPT
Date: 2025-10-15
Topic: Adding interactive button handlers with ipywidgets for temperature and precipitation charts

Me: I’ve added the helper function for temperature advice. Now I want to make my buttons interactive, starting with the “Fetch Weather” button. Can you show me how to handle that with ipywidgets?

AI: Sure. You can define a function that runs when the user clicks the button. Use the on_click() method and include a small handler like this:

def on_fetch_button_clicked(b, location_input, days_input, output_area):
    with output_area:
        output_area.clear_output()
        loc = location_input.value
        if not loc:
            print("⚠️ Please enter a location.")
            return
        data = get_weather_data(loc, forecast_days=6)
        if data and data.get("list"):
            current = data["list"][0]
            print(f"✨ Weather for {loc}: ✨")
            print(f"🌡️ Currently: {current['main']['temp']:.1f}°C with {current['weather'][0]['description']}")


This prints basic weather info whenever the button is clicked.

Me: Okay, that makes sense. What about the chart buttons? I want “📈 Show Temperature Chart” to display the daily temperature line chart, and “💧 Show Precipitation Chart” to display the bar chart for rainfall.

AI: You can create separate handlers for those. Here’s the one for the temperature chart:

def on_temp_chart_button_clicked(b, location_input, days_input, output_area):
    with output_area:
        output_area.clear_output()
        loc = location_input.value
        if not loc:
            print("⚠️ Please enter a location.")
            return
        global _LAST_WEATHER, _LAST_LOCATION
        if not _LAST_WEATHER or _LAST_LOCATION != loc:
            print(f"🔄 Fetching weather data for {loc}...")
            data = get_weather_data(loc, forecast_days=6)
            _LAST_WEATHER = data
            _LAST_LOCATION = loc
        if not _LAST_WEATHER or not _LAST_WEATHER.get("list"):
            print("❌ Could not retrieve data for chart.")
            return
        num_days_chart = days_input.value
        print("📈 Displaying temperature chart...")
        create_temperature_visualisation(_LAST_WEATHER, num_days=num_days_chart, output_type='display')


Me: That’s clear. And for the precipitation chart, it should be basically the same, right?

AI: Yes, almost identical — the only difference is which chart function you call. For precipitation, use:

def on_precip_chart_button_clicked(b, location_input, days_input, output_area):
    with output_area:
        output_area.clear_output()
        loc = location_input.value
        if not loc:
            print("⚠️ Please enter a location.")
            return
        global _LAST_WEATHER, _LAST_LOCATION
        if not _LAST_WEATHER or _LAST_LOCATION != loc:
            print(f"🔄 Fetching weather data for {loc}...")
            data = get_weather_data(loc, forecast_days=6)
            _LAST_WEATHER = data
            _LAST_LOCATION = loc
        if not _LAST_WEATHER or not _LAST_WEATHER.get("list"):
            print("📊 Weather data unavailable for precipitation chart.")
            return
        num_days_chart = days_input.value
        print("💧 Displaying precipitation chart...")
        create_precipitation_visualisation(_LAST_WEATHER, num_days=num_days_chart, output_type='display')


Me: Perfect. I like that both use the same number of days from the input field.

AI: Yes, keeping them consistent gives a smoother experience. You could also add small prints like “Fetching weather data…” so users know what’s happening while the chart loads.

Me: Good idea. Also, when I click the temperature chart button multiple times, does it fetch data again?

AI: Only if you design it that way. In your current setup, it checks if the location has changed. If _LAST_LOCATION is the same, it reuses the last data to avoid unnecessary API calls. That makes it more efficient.

Me: Great, that’s exactly what I wanted. I also noticed the charts look really nice when shown side by side in the notebook.

AI: That’s awesome. You can control that layout later if you want, but for now, your button handlers are perfectly functional. Together with your Fetch and Advice functions, your interface already feels quite polished.

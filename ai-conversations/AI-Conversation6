Tool: ChatGPT
Date: 2025-10-14
Topic: Parsing user questions and generating weather responses

Me: I want to make my weather advisor a bit smarter. I’d like it to understand questions like “What’s the temperature in Perth today?” or “Will it rain tomorrow in Sydney?” How should I start building a parser for that?

AI: That’s a great idea. You can create a simple function called parse_weather_question() that analyses the text and extracts useful details, such as the location, time period, and weather attribute. The basic structure would be:

Input: a natural language question (string)

Output: a dictionary containing location, time_period, and weather_attribute

This doesn’t require heavy NLP libraries — you can start with string and regex operations to detect keywords.

Me: Okay, can you help me design the function step by step?

AI: Sure. Let’s start with an outline:

def parse_weather_question(question):
    parsed_info = {
        "question": question,
        "location": None,
        "time_period": None,
        "weather_attribute": None
    }
    # Your logic goes here
    return parsed_info


From there, we can add small keyword checks to fill in the missing pieces.

Me: For location detection, should I use something simple like capitalized words, or do I need an API?

AI: Since this is for a classroom project, a simple rule-based approach is fine. You can look for capitalized words because city names usually start with capital letters. For example:

words = question.split()
capitalized_words = [word for word in words if word and word[0].isupper()]
if capitalized_words:
    parsed_info["location"] = capitalized_words[0]


This won’t be perfect, but it’s lightweight and good enough for demo purposes.

Me: That’s simple enough. What about the time period? I want it to understand “today,” “tomorrow,” or “next 5 days.”

AI: You can check for those keywords directly using if statements. For example:

question_lower = question.lower()
if "today" in question_lower:
    parsed_info["time_period"] = "today"
elif "tomorrow" in question_lower:
    parsed_info["time_period"] = "tomorrow"
elif "next" in question_lower and "day" in question_lower:
    match = re.search(r"next\s+(\d+)\s+days", question_lower)
    if match:
        parsed_info["time_period"] = f"next {match.group(1)} days"
    else:
        parsed_info["time_period"] = "next few days"


This covers the most common cases without making it too complex.

Me: Nice. And what about figuring out what the user wants to know — like temperature, rain, or wind?

AI: You can do that by scanning for specific words or phrases. For example:

if "temperature" in question_lower or "how hot" in question_lower or "how cold" in question_lower:
    parsed_info["weather_attribute"] = "temperature"
if "rain" in question_lower or "precipitation" in question_lower:
    parsed_info["weather_attribute"] = "precipitation"
if "wind" in question_lower or "windy" in question_lower:
    parsed_info["weather_attribute"] = "wind"


It’s not advanced NLP, but it’s very effective for simple natural language input.

Me: Okay, I’ve put it all together like this. Can you check if this looks right?

def parse_weather_question(question):
    parsed_info = {
        "question": question,
        "location": None,
        "time_period": None,
        "weather_attribute": None
    }

    words = question.split()
    capitalized_words = [word for word in words if word and word[0].isupper()]
    if capitalized_words:
        parsed_info["location"] = capitalized_words[0]

    question_lower = question.lower()
    if "today" in question_lower:
        parsed_info["time_period"] = "today"
    elif "tomorrow" in question_lower:
        parsed_info["time_period"] = "tomorrow"
    elif "next" in question_lower and "day" in question_lower:
        match = re.search(r"next\s+(\d+)\s+days", question_lower)
        if match:
            parsed_info["time_period"] = f"next {match.group(1)} days"
        else:
            parsed_info["time_period"] = "next few days"

    if "temperature" in question_lower or "how hot" in question_lower or "how cold" in question_lower:
        parsed_info["weather_attribute"] = "temperature"
    if "rain" in question_lower or "precipitation" in question_lower:
        parsed_info["weather_attribute"] = "precipitation"
    if "wind" in question_lower or "windy" in question_lower:
        parsed_info["weather_attribute"] = "wind"

    return parsed_info


AI: Yes, that’s very good. It’s readable, well-documented, and functional. It uses simple heuristics that make sense for your project. You could improve it later by using a proper NLP library, but for now, this is completely appropriate.

Me: Thanks. Now I want to connect it with another function called generate_weather_response(). It should take the parsed info and respond with something like “The temperature in Perth today is 28°C.” How can I do that?

AI: You can build it by using the output from your parsing function and combining it with the data you’ve already retrieved from the OpenWeather API. Conceptually, it works like this:

Get the location and time period from the parsed question.

Retrieve the weather data for that location.

Check what attribute the user wants.

Return a short, human-readable response.

Here’s a simple example structure:

def generate_weather_response(parsed_info, weather_data):
    location = parsed_info.get("location")
    attribute = parsed_info.get("weather_attribute")
    period = parsed_info.get("time_period")

    if not location or not attribute:
        return "Sorry, I couldn’t understand your question completely."

    if attribute == "temperature":
        current_temp = weather_data["list"][0]["main"]["temp"]
        return f"The temperature in {location} {period or 'now'} is {current_temp}°C."
    elif attribute == "precipitation":
        rain = weather_data["list"][0].get("rain", {}).get("3h", 0)
        return f"The expected rainfall in {location} {period or 'today'} is {rain} mm."
    elif attribute == "wind":
        wind_speed = weather_data["list"][0]["wind"]["speed"]
        return f"The wind speed in {location} {period or 'today'} is {wind_speed} m/s."
    else:
        return "I’m not sure what weather detail you’re asking for."


Me: That looks good. I like that it’s short but covers all attributes. So if I ask “Will it rain tomorrow in Sydney?”, it will extract “Sydney”, “tomorrow”, and “precipitation”, then look for the rain data.

AI: Exactly. It’s a clean way to connect natural language with your weather functions. Once you test it with your API data, you can adjust the output messages to make them sound more conversational or add error checks for missing data.

Me: Perfect. I’ll integrate these two functions into the main script so the user can type questions directly.

AI: That’s a great idea. These two functions form the conversational layer of your weather advisor. Together with your data retrieval and visualisation parts, your system now has end-to-end functionality — from understanding the user’s question to displaying a visual response.

Tool: ChatGPT
Date: 2025-10-12
Topic: Building and integrating get_weather_data() and temperature extraction logic

Me: I’ve finished my openWeather_getWeather function, I want to build another function that can process the weather data, like extracting daily temperatures. How should I approach that?

AI: That’s a good next step. Right now, your openWeather_getWeather() function returns raw JSON data that includes a "list" field containing weather forecasts every 3 hours for 5 days. To make it more readable, you can extract and group temperatures by date.

Here’s an example of how to do that:

def get_temps(data):
    daily_temps = {}
    for item in data["list"]:
        dt_txt = item["dt_txt"]  # e.g. "2025-10-16 03:00:00"
        date_str = dt_txt.split(" ")[0]
        temp = item["main"]["temp"]

        if date_str not in daily_temps:
            daily_temps[date_str] = []

        daily_temps[date_str].append(temp)
    return daily_temps


This gives you a dictionary where each date is a key, and each value is a list of temperatures recorded throughout that day.

Me: Okay, please explain what this line means:

dt_txt.split(" ")[0]


I see it often, but I don’t fully understand what it’s doing.

AI: The "dt_txt" field in the OpenWeather API looks like "2025-10-16 03:00:00". When you use .split(" "), it splits the string into two parts: the date and the time. The [0] part takes only the first piece, which is the date. That’s why you end up with something like "2025-10-16" instead of the full timestamp.

Me: That makes sense now. But when I ran this, I got a KeyError: 'list'. Why is that happening?

AI: That usually means the JSON you got back from the API doesn’t have a key called "list". It could be that the city name was invalid or the API key wasn’t recognized. You can avoid that error by adding a small check before you start looping:

if "list" not in data:
    print("Error: Invalid or missing weather data")
    return {}


That way, your program will fail safely and tell you what went wrong.

Me: That’s helpful. Now I want to create a main function called get_weather_data() that uses both openWeather_getWeather() and get_temps(). I want it to return a summary with the city, number of forecast days, and temperatures. How can I do that?

AI: You can design it as a controller function that handles both retrieval and processing. Here’s a simple structure:

def get_weather_data(city: str, forecast_days: int = 5):
    try:
        response = openWeather_getWeather(city=city, units="metric")
        temps = get_temps(response)
        return {
            "location": city,
            "forecast_days": forecast_days,
            "daily": temps
        }
    except Exception as e:
        return {"error": f"Failed to fetch weather data: {e}"}


This approach keeps your code modular and makes the output easier to use later when you build visualisations.

Me: I like that idea. But what happens if someone enters a city that doesn’t exist? Right now, the function just crashes.

AI: You can handle that by checking if the response from openWeather_getWeather() contains an error. The API usually returns a field called "cod", which equals "200" when it succeeds. Try this version:

def get_weather_data(city: str, forecast_days: int = 5):
    response = openWeather_getWeather(city=city, units="metric")
    if not response or response.get("cod") != "200":
        return {"error": response.get("message", "Invalid city or API error")}
    
    temps = get_temps(response)
    return {
        "location": city,
        "forecast_days": forecast_days,
        "daily": temps
    }


That way, you always return a consistent dictionary, even when something fails.

Me: That’s useful. I also tried this simpler version just to test things:

def get_weather_data(city: str, forecast_days: int = 5):
    try:
        response = openWeather_getWeather(city=city, units="metric")
        return response
    except Exception as e:
        response["error"] = f"Failed to fetch weather data: {e}"
        return response


Is it okay if I leave it like this for now?

AI: Yes, that’s completely fine for testing. Returning the raw response helps you explore what kind of data you’re getting. Once you’re ready, you can process it more cleanly or summarize specific parts like average temperatures or weather icons.

Me: Please check if my combined code looks consistent so far.

class ParsedWeather(TypedDict, total=False):
    location: str
    forecast_days: int
    error: Optional[str]
    current: Dict[str, Any]
    daily: List[Dict[str, Any]]


def openWeather_getWeather(city: str, units: str = "metric"):
    api_key = os.getenv("OPENWEATHER_API_KEY")
    if not api_key:
            return None
    try:
            CITY = city
            UNITS = units
            url = f"https://api.openweathermap.org/data/2.5/forecast?q={CITY}&appid={api_key}&units={UNITS}"
            response = requests.get(url)
            data = response.json()
            return data
    except Exception as e:
            print(f"Error fetching weather data: {e}")
            return None


def get_temps(data):
        daily_temps = {}
        for item in data["list"]:
                dt_txt = item["dt_txt"]
                date_str = dt_txt.split(" ")[0]
                temp = item["main"]["temp"]
                if date_str not in daily_temps:
                        daily_temps[date_str] = []
                daily_temps[date_str].append(temp)
        return daily_temps


def get_weather_data(city: str, forecast_days: int = 5):
    try:
            response = openWeather_getWeather(city=city, units="metric")
            return response
    except Exception as e:
            response["error"] = f"Failed to fetch weather data: {e}"
            return response


AI: The structure looks consistent and logical. You could consider initializing response = {} before the try block to prevent a reference error if something goes wrong early, but otherwise everything looks fine. Later, when you want to visualize data, you can modify get_weather_data() to calculate averages or include other fields like humidity and weather description.

Me: Okay, I’ll keep it like this for now and improve it later when I start visualising the data.

AI: That sounds like a good plan. You’ve built a clear foundation that separates data retrieval, processing, and control. This structure will make debugging and expanding much easier later on.

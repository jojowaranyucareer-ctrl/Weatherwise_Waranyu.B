Tool: ChatGPT
Date: 2025-10-15
Topic: Tying everything together – generating AI-powered weather responses

Me:  I want to connect everything together so that the program can respond naturally to a user’s question. Can you help me figure out how to do that?

AI: Sure. The final step is to combine your existing functions into one that can understand a question, gather weather data, and generate a natural language answer. You can create a function called generate_weather_response() that takes two inputs: the parsed question from parse_weather_question() and the weather data from openWeather_getWeather(). The function will then build a context string summarising the weather and pass it along with the question to the AI for a response.

Me: So it’s like the final layer that brings everything together, right?

AI: Exactly. You can think of it as the part that makes your project conversational. It connects the data logic with your AI’s text generation.

Me: Can you show me what a basic version would look like?

AI: Sure, here’s a starting point.

def generate_weather_response(parsed_question, weather_data):
    question = parsed_question.get("question", "")
    location = parsed_question.get("location")
    time_period = parsed_question.get("time_period")
    weather_attribute = parsed_question.get("weather_attribute")

    if not question:
        return "No question provided."

    weather_context = "Weather information:"

    if not weather_data or not weather_data.get("list"):
        weather_context += " Weather data not available."
    else:
        current = weather_data["list"][0]
        weather_context += f" Current: Temp: {current['main']['temp']:.1f}°C, Conditions: {current['weather'][0]['description']}, Humidity: {current['main']['humidity']}%, Wind: {current['wind']['speed']} m/s."


This section builds a short summary of the current weather. You can then extend it to include tomorrow’s forecast or the next few days.

Me: I noticed in some examples people use [8:16] to get tomorrow’s data. Why that range?

AI: Good question. OpenWeatherMap provides forecasts in 3-hour intervals. There are eight time points per day, so the next eight records after the first day (indices 8 to 15) correspond to tomorrow’s weather. You can use them to calculate averages for temperature and total precipitation.

Me: That helps a lot. I wrote this version based on your explanation.

def generate_weather_response(parsed_question: Dict[str, Any], weather_data: Dict[str, Any]) -> str:
    question = parsed_question.get("question", "")
    location = parsed_question.get("location")
    time_period = parsed_question.get("time_period")
    weather_attribute = parsed_question.get("weather_attribute")

    if not question:
        return "No question provided."

    weather_context = "Weather information:"

    if not weather_data or not weather_data.get("list"):
        weather_context += " Weather data not available."
    else:
        current = weather_data["list"][0]
        weather_context += f" Current: Temp: {current['main']['temp']:.1f}°C, Conditions: {current['weather'][0]['description']}, Humidity: {current['main']['humidity']}%, Wind: {current['wind']['speed']} m/s."

        if time_period and len(weather_data.get('list', [])) > 8:
            if time_period == "tomorrow":
                tomorrow_data_points = weather_data["list"][8:16]
                if tomorrow_data_points:
                    tomorrow_date = tomorrow_data_points[0]["dt_txt"].split(" ")[0]
                    tomorrow_temps = [item["main"]["temp"] for item in tomorrow_data_points]
                    average_temp_tomorrow = sum(tomorrow_temps) / len(tomorrow_temps) if tomorrow_temps else 0
                    tomorrow_precipitation = sum(item.get("rain", {}).get("3h", 0) + item.get("snow", {}).get("3h", 0) for item in tomorrow_data_points)
                    tomorrow_weather_description = tomorrow_data_points[0]["weather"][0]["description"]
                    weather_context += f" Tomorrow ({tomorrow_date}): Average Temp: {average_temp_tomorrow:.2f}°C, Precipitation: {tomorrow_precipitation:.2f} mm, Conditions: {tomorrow_weather_description}."
            elif time_period.startswith("next"):
                num_days_str = time_period.split(" ")[1] if len(time_period.split(" ")) > 1 else "few"
                weather_context += f" Forecast for the next {num_days_str} days is available."

    ai_prompt = f"{weather_context}\n"

    if location:
        ai_prompt += f"Regarding the weather in {location}, "
    if time_period:
        ai_prompt += f"for the period {time_period}, "
    if weather_attribute:
        ai_prompt += f"focusing on the {weather_attribute}, "

    ai_prompt += f"please answer the following question: {question}"

    try:
        ai_response = get_response(ai_prompt)
        return ai_response
    except Exception as e:
        return f"Error getting AI response: {e}"


AI: This looks great. You’ve managed to combine all the key parts clearly: parsing, summarising, and generating an AI response. It’s clean, logical, and well structured.

Me: I’m happy with how it turned out. Do you think the way I build the weather_context string is okay, or is it too long?

AI: It’s fine for your current version. If you want to make it more maintainable later, you can separate the logic for current conditions and forecasts into smaller helper functions. But right now, it’s perfectly readable.

Me: That’s good to know. I’ll keep it as one function for now. I’ll test it by asking something like “What will the weather be tomorrow in Perth?” and see what kind of response it gives.

AI: That’s the perfect way to test it. If that question gives a meaningful answer, you’ll know your whole system is working correctly from parsing the question all the way to generating an AI-based response.
